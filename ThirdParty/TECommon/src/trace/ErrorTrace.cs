//////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2001-2004, Andrew S. Townley
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 
//     * Redistributions of source code must retain the above
//     copyright notice, this list of conditions and the following
//     disclaimer.
// 
//     * Redistributions in binary form must reproduce the above
//     copyright notice, this list of conditions and the following
//     disclaimer in the documentation and/or other materials provided
//     with the distribution.
// 
//     * Neither the names Andrew Townley and Townley Enterprises,
//     Inc. nor the names of its contributors may be used to endorse
//     or promote products derived from this software without specific
//     prior written permission.  
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
// OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Name:	ErrorTrace.cs
// Created:	Sat Jun 26 17:58:03 IST 2004
//
///////////////////////////////////////////////////////////////////////

using System;

namespace TownleyEnterprises.Trace {

//////////////////////////////////////////////////////////////////////
/// <summary>
///   <para>
///   This class may be used to provide complete instrumentation of
///   source code as an alternative to the BasicTrace implementation.
///   The main differences are when the method call stack for the
///   current thread is popped.  With the BasicTrace class, it is only
///   popped when Exit is called.  With this class, it is popped
///   whenever one of MethodReturn or MethodThrow has been called.
///   </para>
/// </summary>
/// <remarks>
///   <para>
///   To use this class to instrument a class, the following pattern
///   should be applied.  Each method in the class should have similar
///   code to the following and a single, static trace instance should
///   be created for the class.
///   </para>
/// <example>
/// <code>
/// class MyClass
/// {
/// 	// create a shared instance and give it a trace threshold of 0
/// 	private static ErrorTrace _trace = new ErrorTrace("MyClass", 0)
/// 	...
/// 
/// 	// define the names of the parameters as static so they aren't
/// 	// created each time you need them.
/// 	private static _myMethodParams = new string[] {"param1", "param2" };
/// 	
/// 	public int MyMethod(string param1, int param2)
/// 	{
/// 		_trace.MethodStart("MyMethod", _myMethodParams,
/// 			new object[] { param1, param2 });
/// 		
/// 		int rc = 0;
/// 		try
/// 		{
/// 			// some code that can throw an exception
/// 			StreamReader read = new	StreamReader("/bogus");
/// 		}
/// 		catch(IOException e)
/// 		{
/// 			throw (IOException)_trace.MethodThrow(e);
/// 		}
/// 		catch(Exception e)
/// 		{
/// 			throw (Exception)_trace.MethodThrow(e);
/// 		}
/// 
/// 		...
/// 
/// 		// log any exceptions generated by me
/// 		if(_somethingBad)
/// 		{
/// 			throw (Exception)_trace.MethodThrow(new
/// 				Exeption("I have a bad feeling about this..."));
/// 		}
/// 
/// 		...
/// 
/// 		return _trace.MethodReturn(rc);
/// 	}
/// }
/// </code>
/// </example>
///   <para>
///   The rationale for two different mechanisms is that with
///   BasicTrace, you do not always log the root source of the
///   exceptions.  This can make the cause of the problem somewhat
///   difficult to track down.  By using the ErrorTrace class and
///   associated pattern, you have the exception stack trace and the
///   parameters in the same place, so it is easy to tell what caused
///   the problem.
///   </para>
///   <para>
///   Like all things, there is a down-side:  to perform this level of
///   instrumentation and make sure that you don't have any stealth
///   exceptions messing up your stack trace, you have to write a lot
///   of try..catch blocks.  Based on the behavior of the class and
///   the number of calls liable to throw exceptions, you have to make
///   a choice between the two patterns.
///   </para>
///   <para>
///   With practical deployment of systems using both approaches, this
///   is probably overkill for the general use.  BasicTrace gives most
///   of the information you need most of the time.  However, there
///   have been several times code instrumented with ErrorTrace vs.
///   BasicTrace has provided quicker debugging and diagnosis.
///   Unfortunately, there isn't any hard evidence to say which one is
///   actually the best approach.
///   </para>
///   <para>
///   The idea here is that you still get the entry and exit in the
///   normal case, but you don't have to attempt to check for all the
///   possible exceptions which can be thrown (and upset the method
///   name stack of the MethodTrace class).
///   </para>
/// </remarks>
/// <version>$Id: ErrorTrace.cs,v 1.2 2004/07/19 16:50:09 atownley Exp $</version>
/// <author><a href="mailto:adz1092@netscape.net">Andrew S. Townley</a></author>
//////////////////////////////////////////////////////////////////////
 
public class ErrorTrace: MethodTrace
{
	//////////////////////////////////////////////////////////////
	/// <summary>
	///   Initializes the TraceCore instance.
	/// </summary>
	/// <param name="name">the identifier to be printed in the
	/// trace logs</param>
	//////////////////////////////////////////////////////////////

	public ErrorTrace(string className) :base(className, 0)
	{
	}

	//////////////////////////////////////////////////////////////
	/// <summary>
	///   Initializes the TraceCore instance using the specified
	///   maturity.
	/// </summary>
	/// <param name="name">the identifier to be printed in the
	/// trace logs</param>
	/// <param name="maturity">the relative maturity of this class
	/// (see the TraceCore documentation for a complete
	/// explaination)</param>
	//////////////////////////////////////////////////////////////

	public ErrorTrace(string className, int maturity)
		: base(className, maturity)
	{
	}

	public override void MethodReturn()
	{
		base.MethodReturn();
		PopCurrentMethod();
	}

	public override bool MethodReturn(bool arg)
	{
		base.MethodReturn(arg);
		PopCurrentMethod();
		return arg;
	}

	public override byte MethodReturn(byte arg)
	{
		base.MethodReturn(arg);
		PopCurrentMethod();
		return arg;
	}

	public override char MethodReturn(char arg)
	{
		base.MethodReturn(arg);
		PopCurrentMethod();
		return arg;
	}

	public override decimal MethodReturn(decimal arg)
	{
		base.MethodReturn(arg);
		PopCurrentMethod();
		return arg;
	}

	public override double MethodReturn(double arg)
	{
		base.MethodReturn(arg);
		PopCurrentMethod();
		return arg;
	}

	public override float MethodReturn(float arg)
	{
		base.MethodReturn(arg);
		PopCurrentMethod();
		return arg;
	}

	public override int MethodReturn(int arg)
	{
		base.MethodReturn(arg);
		PopCurrentMethod();
		return arg;
	}

	public override long MethodReturn(long arg)
	{
		base.MethodReturn(arg);
		PopCurrentMethod();
		return arg;
	}

	public override object MethodReturn(object arg)
	{
		base.MethodReturn(arg);
		PopCurrentMethod();
		return arg;
	}

//	public override sbyte MethodReturn(sbyte arg)
//	{
//		base.MethodReturn(arg);
//		PopCurrentMethod();
//		return arg;
//	}

	public override short MethodReturn(short arg)
	{
		base.MethodReturn(arg);
		PopCurrentMethod();
		return arg;
	}

	public override string MethodReturn(string arg)
	{
		base.MethodReturn(arg);
		PopCurrentMethod();
		return arg;
	}

//	public override uint MethodReturn(uint arg)
//	{
//		base.MethodReturn(arg);
//		PopCurrentMethod();
//		return arg;
//	}
//
//	public override ulong MethodReturn(ulong arg)
//	{
//		base.MethodReturn(arg);
//		PopCurrentMethod();
//		return arg;
//	}

	public override Traceable MethodReturn(Traceable arg)
	{
		base.MethodReturn(arg);
		PopCurrentMethod();
		return arg;
	}

	public override Exception MethodThrow(Exception ex, bool print)
	{
		base.MethodThrow(ex, print);
		PopCurrentMethod();
		return ex;
	}
}

}
